{
    "sourceFile": "lib/genserver_supervisor/my_genserver.ex",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1726225801514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1726225806736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-defmodule Exampels.MyGenServer do\n+defmodule Examples.MyGenServer do\n   @moduledoc \"\"\"\n     Outside the process that we create here,\n     there could be a storm raging. But inside, things are calm.\n     Here we can focus on what that process should do - and only that.\n"
                }
            ],
            "date": 1726225801514,
            "name": "Commit-0",
            "content": "defmodule Exampels.MyGenServer do\n  @moduledoc \"\"\"\n    Outside the process that we create here,\n    there could be a storm raging. But inside, things are calm.\n    Here we can focus on what that process should do - and only that.\n  \"\"\"\n  use GenServer\n  require Logger\n\n  ###################################################################\n  # API - where we define what the outside world can \"ask\" us to do #\n  ###################################################################\n\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts[:name], opts)\n  end\n\n  def stop(pid) do\n    GenServer.stop(pid)\n  end\n\n  def add_list_items(list, pid) do\n    GenServer.call(pid, {:add, list})\n  end\n\n  def get_count(pid) do\n    GenServer.call(pid, :get_count)\n  end\n\n  def get_info_calls(pid) do\n    GenServer.call(pid, :get_info_calls)\n  end\n\n  def subtract_list_items(list, pid) do\n    GenServer.cast(pid, {:subtract, list})\n  end\n\n  def reset_counter(pid) do\n    GenServer.cast(pid, :reset_counter)\n  end\n\n  #############################################################################\n  # Callbacks - our boundary between the outside world and our business logic #\n  #           - we also manage our State here\n  #############################################################################\n  @impl true\n  def init(name) do\n    Logger.info(\"Starting #{name}\")\n    init_state = %{counter: 0, name: name, info_calls: []}\n    {:ok, init_state}\n  end\n\n  @impl true\n  def terminate(:normal, state) do\n    Logger.info(\"Stopping #{state[:name]}\")\n  end\n\n  @impl true\n  def handle_call({:add, list}, _, state) do\n    count = add(list, state[:counter])\n    Logger.info(\"New Counter Value is #{count}\")\n    new_state = %{state | counter: count}\n    {:reply, count, new_state, {:continue, :add_one}}\n  end\n\n  @impl true\n  def handle_call(:get_count, _, state) do\n    {:reply, state[:counter], state}\n  end\n\n  @impl true\n  def handle_call(:get_info_calls, _, state) do\n    {:reply, state[:info_calls], state}\n  end\n\n  @impl true\n  def handle_cast({:subtract, list}, state) do\n    count = subtract(list, state[:counter])\n    Logger.info(\"New Counter Value is #{count}\")\n    new_state = %{state | counter: count}\n    {:noreply, new_state}\n  end\n\n  @impl true\n  def handle_cast(:reset_counter, state) do\n    {:noreply, %{state | counter: 0}}\n  end\n\n  @impl true\n  def handle_continue(:add_one, state) do\n    new_state = %{state | counter: state[:counter] + 1}\n    {:noreply, new_state}\n  end\n\n  @impl true\n  def handle_info(:flush_info_calls, state) do\n    new_state = %{state | info_calls: []}\n    {:noreply, new_state}\n  end\n\n  @impl true\n  def handle_info(message, state) do\n    Logger.info(\"Handle Info called with message #{message}\")\n    collected_calls = [message | state[:info_calls]]\n    new_state = %{state | info_calls: collected_calls}\n    {:noreply, new_state}\n  end\n\n  ###########################################\n  # Private Functions - The functional core #\n  ###########################################\n\n  defp add([], counter), do: counter\n\n  defp add([item | list], counter) do\n    case counter do\n      0 -> add(list, item)\n      _ -> add(list, counter + item)\n    end\n  end\n\n  defp subtract(_, 0), do: 0\n\n  defp subtract([], counter), do: counter\n\n  defp subtract([item | list], counter) do\n    case will_be_null?(counter, item) do\n      true -> 0\n      false -> subtract(list, counter - item)\n    end\n  end\n\n  defp will_be_null?(counter, item) do\n    counter - item <= 0\n  end\nend\n"
        }
    ]
}